### 第一章 你好设计模式
* 对象创建，接口适应，对象去耦合 抽象集合  行为扩展 算法封装 性能与对象访问 以及对象状态
* 
#### 复合设计模式的MVC 

### 对象创建
### 第三章 原型
* 原型模式：是一种创建型设计模式,它通过复制一个已经存在的实例来返回新的实例,而不是新建实例

### 第四章 工厂方法
* 定义创建对象的接口 让子类决定实例化那一个类 工厂方法使得一个类的实例化延迟到其子类 
* 工厂类通常包含一个静态方法 ，由该方法根据输入类型负责创建具体的对象 
* 通过工厂类根据参数负责创建具体的产品，即工厂类在工厂方法中通过对参数进行条件判断（if switch ）来创建不同的实例
根据不同的type创建不同的子类实例对象


### 第五章 抽象工厂 
* 通过组合创建抽象产品
* 创建多系列产品
* 必须修改父类接口才能支持新的产品
* 调用一个抽象类 
* 可以创建多个不同的实力对象
* 抽象工厂模式一种极为常见的设计模式 。他是最基本的 ， 因为他可以涉及许多类型的对象创建 。一系列相关
类的好的模式 ，应该作为抽象 不为客户端所见 抽象工厂可以顺畅的提供这种抽象 ，而不暴露创建过程中任何不必要的细节
或所创建对象的确切类型 

### 第六章 生成器模式
* [iOS中的设计模式——生成器(Builder)](http://ibloodline.com/articles/2016/09/18/Builder.html)
* 生成器模式： 将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现
* 生成器模式能帮助构建涉及部件与表现的各种组合的对象。 没有这一模式，知道构建对象所需的细节可能最终编程一个庞大的
类
* 创建A 再根据A创建B 

### 第七章 单例模式  
* 单例模式意图类的一个对象成为系统中唯一的一个实例 保证一个类仅有一个实例，并提供一个访问它的全局访问点
* 几乎在任何类型的应用程序中， 单例模式都极为常用 ，只要应用程序需要用集中式的类来协调其服务，这个类就应该生成
单一的实例 而不是多个实例
* 单例对象一旦建立，对象指针保存在静态区，单例对象在堆中分配的内存空间，只在应用程序终止后才会被释放

### 接口适配

### 适配器模式  
* 通用性  机械键盘 创建函数 技术实现 新建工程 
* 协议是定义一些行为   
* 适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类
可以一起工作  使用协议来实现适配器模式
* 实际应用场景自定义view ，声明协议 遵守我的协议 就可以把数据传递进来  实现view 和model解耦合 

### 桥接 
* 桥接模式的目的是把抽象层次结构从其实现中分离出来 使其能够独立变更
* 抽象层定义了供客户端使用的上层的抽象接口
* 实现层次结构定义了供抽象层次使用的的底层接口
* 如何从实现中把抽象分离出来而又要让它们联系在一起的时候  我们就用桥接模式
* 桥接模式可以做多维度的组合 

### 外观模式
* 外观模式为子系统中不同的接口提供统一的接口。外观定义了上层接口 ，通过降低复杂度和隐藏子系统间的通信
依赖关系 让子系统更易于使用

### 第四部分 对象去耦合
### 中介者
* 中介者模式： 用一个对象来封装一系列对象的交互方式。 中介者使对象不需要显式的相互引用，从而使其耦合松散
而且可以独立改变它们之间的交互
* 作为中介者 完成两个甚至多个组件通信 

### 观察者模式 
* 观察者模式也叫发布订阅模式 
* 定义对象间的一种一对多依赖关系 当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
### 第五部分 抽象集合
### 组合模式
* 组合模式让我们可以把相同基类型的对象组合到树状结构中  

### 迭代器模式 
* 提供一种方法顺序访问一个聚合对象中的各个元素 ，而又不需暴露该对象的内部表示

### 第六部分行为扩展

### 访问者模式
> 在以下场景，可以使用访问者模式
* 一个复杂的对象结构包含很多其他对象，它们又不同的接口
* 定义复杂结构的类很少做修改 但经常需要向其添加新的操作

* 访问者模式：在系统中增加一种新的访问者，无须修改源代码，只要增加一个新的具体访问者类即可，比如新增HR部门


### 装饰模式  
* 装饰模式 : 动态地给一个对象添加一些额外的职责。 就扩展功能来说，装饰模式相比生成子类更为灵活

### 责任链模式  
* 责任链的主要思想， 对象引用了同一个类型的另一个对象 形成一个链 
* 避免请求发送者与接受者耦合在一起 ，让多个对象都有可能接收请求 ，将这些对象连接成一条链条，并且
沿着这条链传递请求 ，直到有对象处理它为止 
* [Objective-C设计模式解析-责任链](https://segmentfault.com/a/1190000011449768)

### 第七部分算法封装

### 模板方法模式 
* 模板方法模式: 定义一个操作中算法骨架 ，而将一些操作延迟到子类中 。模板使子类可以重定义算法的某些
特定步骤而不改变算法的结构  翻译过程就是  固定框架  子类可以有不同的实现  

### 策略模式  
* 定义一系列算法  ，把他们一个个封装起来 ，并且使他们可以相互替换。本模式使得算法可独立于使用它的客户变化
* 父类声明  子类各自实现  这样解耦合


